#!/usr/bin/env bash
# -*- bash -*-
#
#
ARGS="$@"
ignore="$IGNORE"
action="$1"
IS_DEV="$IS_DEV"
shift

set -u -e -o pipefail

THIS_DIR="/apps/bash_setup"
BIN=/apps/bash_setup/bin

Color_Off='\e[0m'
Bold="$(tput bold)"
Reset='\e[0m'
BRed='\e[1;31m'
Red='\e[0;31m'
Green='\e[0;32m'
BGreen='\e[1;32m'
Orange='\e[0;33m'
BOrange='\e[1;33m'


function git_is_clean {
    if ! git_repo_is_clean
    then
      echo -e "\n!!! GIT repo not clean enough.\n" 1>&2
      exit 1
    fi
}

function make_link {
  local orig=$1
  local target=$2

  # IF broken link exists, remove
  if [[ -h "$target" && ! -e "$(readlink $target)" ]]; then
    echo -e "\n!!! trashing broken link: $target\n"
    trash-put $target
  fi

  # --- IF it does NOT exit?
  if [[ ! -e "$target" ]]
  then # --- create link
    ln -s $orig $target
    echo "--- Linked: $orig $target"
  else

    # --- IF is a sym link?
    if [[ -h "$target" && "$(readlink -f "$target")" == "$(readlink -f $orig)" ]]
    then
      echo "Already sym link: $target"

    else
      echo -e "\n=== Check existing object: $target" 1>&2
      echo -e "\n diff $orig $target\n\n" 1>&2
      exit 1

    fi # --- valid sym link?
  fi # --- ! -e

}


case "$action" in

  "print_help")
    # === === Extract switch options from file
    # ===      that are followed by: # ===
    # === $ bash_setup print_help path/to/file

    file="$1"
    shift
    cmd_print=""
    cmd=""
    nl_printed=""
    IFS=$'\n'
    for line in $(cat $file)
    do
      if [[ $line =~ ^[\*\ +0-9A-Za-z\_\-\'\"]+\)$ ]]; then
        cmd=$(echo $line | tr -d '"'')')
        cmd_print=""
      else
        if [[ -n "$cmd" && $line =~ "# ===" ]]; then
          if [[ -z $cmd_print ]]; then
            echo $cmd
            cmd_print="true"
          fi
          echo ${line/'# ==='/''}
          nl_printed=""
        else
          cmd=""
          if [[ -z $nl_printed ]]; then
            echo ""
            nl_printed="true"
          fi
        fi
      fi

    done
    ;;

  "help"|"--help")
    $0 print_help $0
    ;;

  bump)
    # === bump major|minor|patch
    part="$1"; shift

    if ! git_repo_is_clean; then
      git status
      echo "!!! repo is not clean" 1>&2
      exit 1
    fi

    if [[ ! -e VERSION ]]; then
      git tag -l || :
      echo "!!! File does not exist: VERSION" 1>&2
      exit 1
    fi

    contents="$(cat VERSION)"
    case "$part" in
      major)
        num="$(cat VERSION | cut -d'.' -f1)"
        new_num="$(($num + 1))"
        new_version="$(cat VERSION | sed 's/'$num'\./'$new_num'./')"
        ;;

      minor)
        num="$(cat VERSION | cut -d'.' -f2)"
        new_num="$(($num + 1))"
        new_version="$(cat VERSION | sed 's/\.'$num'\./.'$new_num'./')"
        ;;

      patch)
        num="$(cat VERSION | cut -d'.' -f3)"
        new_num="$(($num + 1))"
        new_version="$(cat VERSION | sed 's/\.'$num'$/.'$new_num'/')"
        ;;

      *)
        echo "!!! Invalid name: $part" 1>&2
        exit 1
        ;;
    esac

    set -x
    echo "$new_version" > VERSION
    git add VERSION
    git commit -m "Bump: v$new_version"
    git tag v"$new_version"
    git push origin v"$new_version"
    git push
    ;;

  dirname_of_bin)
    # === dirname_of_bin path/to/file/or/dir
    # === Removes everything after "/bin"
    target="$@"
    fin=""
    while read -r PART; do
      [[ -z "$PART" ]] && continue || :
      [[ "$PART" == 'bin' ]] && break || :
      fin="$fin/$PART"
    done < <(dirname "$(realpath -m "$target")" | tr '/' '\n')
    [[ -z "$fin" ]] && { echo "!!! Invalid path" 1>&2; exit 1; } || :
    echo "$fin"
    ;;

  trim-file)
    # === __ trim-file  path/to/file
    # === cat path/to/file | __ trim-file
    grep  -Pzo '(?s)\A[\s\n]*\K(.+?)(?=[\s\n]*\Z)' $@
    ;;

  trim)
    sed 's/^#[[:space:]]\+\|[[:space:]]\+$// '
    ;;

  backup)
    file="$1"
    backup="$1.backup"
    if [[ -f "$backup" ]]; then
      echo "Backup file already exists: $backup" 1>&2
      exit 1
    fi
    set -x
    cp -i "$file" "$backup"
    ;;

  "restore")
    file="$1"
    backup="$1.backup"
    if [[ ! -f "$backup" ]]; then
      echo "Backup file does *not* exist: $backup" 1>&2
      exit 1
    fi
    set -x
    { [[ -f "$file" ]] && trash-put $file; } || :
    mv -i "$backup" "$file"
    ;;

  "rel_path_to_file")
    # === $ bash_setup rel_path_to_file  path  start
    # === See: https://docs.python.org/2/library/os.path.html#os.path.relpath
    python -c "import os.path; print os.path.relpath('$1', '$2')"
    ;;

  "upgrade")
    # === upgrade
    case "$@" in
      "fzf")
        cd /progs/fzf
        git pull
        ./install
        ;;

      "fzy")
        $0 install fzy
        ;;

      esac
    ;;

  "install")
    case "$@" in

      "fzf")
        cd /progs
        if [[ ! -d fzf ]]; then
          git clone --depth 1 https://github.com/junegunn/fzf.git
          $0 make_link /progs/fzf $HOME/.fzf
        fi

        ~/.fzf/install
        ;;

      "fzy")
        set -x
        cd /progs
        git_setup clone_or_pull https://github.com/jhawthorn/fzy
        cd fzy
        make
        PREFIX="$PWD" make install
        echo "=== done instaling fzy"
        ;;

      *)
        # === install  # installs various packages/libs
        # === NOTE: libuv is a lib for async I/O
        $0 make_link $THIS_DIR/dots/.bashrc       $HOME/.bashrc
        $0 make_link $THIS_DIR/dots/.bash_profile $HOME/.bash_profile
        sudo pacmatic -S --needed \
          bash-completion   \
          inotify-tools     \
          libuv
        ;;
    esac
    ;; # === install

  "sizes")
    # === $ sizes
    # === $ sizes  folder/path
    folder="./*"
    if [[ -n "$@" ]]; then
      folder="$1"
      shift
    fi
    # du -h $folder | grep --extended-regexp ".*[0-9]G.*" | sort --human-numeric-sort
    du -h --max-depth=0 $folder | sort --human-numeric-sort
    ;;

  "string_to_num")
    str=$1
    shift
    sum=0
    pos=0

    # === $ bash_setup  string_to_num   word  -> num
    while read -n1 char; do
      code="$(printf '%d\n' "'$char")"
      sum=$((sum + pos + code))
      pos=$((pos + 1))
    done < <(echo -n "$str")
    echo $sum
    ;;

  "dev!")
    # === $ bash_setup dev!
    # === Exits with code status 1 if "$IS_DEV" is null
    # === Exits with code status 0 if "$IS_DEV" is not null.
    if [[ -z "$IS_DEV" ]]; then
      echo "!!! Not a dev machine." 1>&2
      exit 1
    fi
    exit 0
    ;;

  "new_bin")
    # === $ bash_setup  new_bin
    # === $ bash_setup  new_bin  name
    if [[ -z "$@" ]]; then
      file_name="$(basename $(pwd))"
    else
      file_name=$1
      shift
    fi
    if [[ -f bin/${file_name} ]]; then
      echo "=== File already exists."
    else
      mkdir -p bin

      cp -i /apps/bash_setup/bin.template.sh bin/${file_name}
      echo "=== Wrote: bin/${file_name}"
    fi

    chmod +x bin/${file_name}
    ;;

  mush?)
    # === $ bash_setup mush? path/to/file.file
    # === If file exists, exists w/ 0, prints nothing to STDOUT.
    # === If file does NOT exists, prints to file,
    # ===  prints/repeats path/to/file.file to STDOUT
    file="$1"
    shift
    if [[ -f $file ]]; then
      exit 0
    else
      bash_setup mush > $file
      echo $file
    fi
    ;;

  mush_unless_exists)
    template="$1"; shift
    target="$1";   shift
    if [[ -e "$target" ]]; then
      echo "=== Skipping existing: $target"
      exit 0
    fi
    cat "$template" | $0 mush
    echo "=== new file: $target"
    ;;

  mush)
    # === Wrapper for mush (Mustache for Bash)
    # === https://github.com/jwerle/mush
    # === Use it just like the mush executable
    mush="${THIS_DIR}/bin/mush"
    if [[ ! -f "$mush" ]]; then
      wget -O $mush "https://raw.githubusercontent.com/jwerle/mush/master/mush.sh"
      chmod +x $mush
    fi
    $mush "$@"
    ;;

  "Capitalize")
    # === $ Capitalize wOrD => Word
    # Based on: http://stackoverflow.com/a/12487465/841803
    word="$1"
    first="$(tr '[:lower:]' '[:upper:]' <<< ${word:0:1})"
    rest="$(tr  '[:upper:]' '[:lower:]' <<< ${word:1})"
    echo "$first$rest"
    ;;

  "Model_Name")
    # === $ Model_Name app_name => App_Name
    # Based on: http://stackoverflow.com/questions/779847/sed-change-case-of-substitution-group
    echo "$@" | sed -e 's/_\([a-z]\)/_\U\1/g' -e 's/^\([a-z]\)/\U\1/g'
    ;;

  "UPPER")
    # === $ lower wOrD => WORD
    word="$1"
    echo "$(tr  '[:lower:]' '[:upper:]' <<< ${word})"
    ;;

  "lower")
    # === $ lower wOrD => word
    word="$1"
    echo "$(tr  '[:upper:]' '[:lower:]' <<< ${word})"
    ;;

  "app_name")
    if [[ -z "$@" ]]; then
      echo "$(basename $(pwd))"
    else
      echo "$1"
    fi
    ;;

  "is_process_group??")
    if $0 is_process_group? $@ ; then
      echo "yes"
    else
      echo "no"
    fi
    ;;

  "SIGINT_descendent_procs")
    pid=$1

    for id in $($0 descendent_procs $pid)
    do
      kill -SIGINT $id || echo "=== Could not SIGINT $id" 1>&2
    done
    ;;

  "descendent_procs")
    # === bash_setup descendent_procs MY_PID
    # === bash_setup descendent_procs MY_PID [args to: ps -p PID ...]
    # === You can then get info on each PID using xargs:
    # === Any other way, and you will get sub-processes/sub-shells.
    # === Example:  bash_setup descende... | xargs ...     # ==> Prints out PIDs of xargs
    # === Example:  while ... done < <(bash_setup desc...) # ==> Prints out PIDs of '<(bash_setup ...)'
    target="$1"
    shift
    this_pid="$$"

    raw="$(pstree -p $target)"
    while read PID
    do
      if [[ "$PID" != "$target" && "$PID" != "$this_pid" ]] && ps --pid $PID &>/dev/null; then
        if [[ -z "$@" ]]; then
          echo $PID
        else
          ps -p $PID "$@"
        fi
      fi
    done < <(echo "$raw" | grep -o '([0-9]\+)' | grep -o '[0-9]\+' )
    ;;

  "proc_tree")
    pstree -a -A  -p -g $@
    ;;

  "proc_group")
    ps -o pgrp --no-headers --pid $1
    ;;

  "is_process_group?")
    [[ $1 == $($0 proc_group $1) ]]
    ;;

  "add_minus_sign_if_pgrp")
    target="$1"
    shift
    if $0 is_process_group? $target ; then
      echo "-$target"
    else
      echo $target
    fi
    ;;

  "watch")
    # === $ bash_setup watch  my_script -myargs -myargs"

    #
    #  For more info on inotifywait:
    #    http://manpages.ubuntu.com/manpages/hardy/man1/inotifywait.1.html
    #
    #  The script will send the output
    #  of inotifywaut to `my_script`.
    #
    #  Files/dirs with .git in the name are ignored.
    #  Example:
    #     .git
    #     ./.git
    #     ./dir/file.git/

    files="$1"
    shift
    cmd="$@"

    if [[ -z "$@" ]]
    then
      echo "No command given. Exiting..." 1>&2
      exit 1
    fi

    # === From an answer by "technosaurus":
    #     http://stackoverflow.com/a/18295696/841803
    echo "=== Watching: $files -> $cmd"
    while read -r CHANGE; do
      dir=$(echo "$CHANGE" | cut -d' ' -f 1)
      op=$(echo "$CHANGE" | cut -d' ' -f 2)
      path="${dir}$(echo "$CHANGE" | cut -d' ' -f 3)"
      file="$(basename $path)"

      echo ""
      echo === $CHANGE === "$cmd"
      eval $cmd || :
    done < <(inotifywait --quiet --monitor --event close_write --exclude .git/ $files)
    ;;



  "o-x")
    # === === make bin files non-executable for others
    # === $ bash_setup o-x dir

    dir="$1"

    chmod o-x $dir/*/bin/*
    for x in $dir/*/bin; do
      echo "=== $x"
      ls -l $x
      echo ""
    done
    ;;

  "files_zero")
    # === $ bash_setup files_zero  substring '*.ext'"

    SUBSTR="$1"
    ext="$2"
    FOUND="no"

    FILES="$(find . -type f -name "$ext" -not -wholename "*/.git*"  -and -not -wholename "*/specs/*" -and -not -wholename "*/bower_components/*" -and -not -wholename "*/vendor/*" -and -not -wholename "*/node_modules/*"  )"

    for FILE in $FILES ; do
      GREPS="$(grep -n "$SUBSTR" $FILE || echo '')"
      if [ ! -z "$GREPS" ]
      then
        echo -e -n "\e[01;31m$FILE\e[0m " 1>&2
        echo "contains $SUBSTR" 1>&2
        echo "$GREPS" 1>&2
        FOUND="yes"
      fi
    done

    if [ "$FOUND" = "yes" ]
    then
      exit 1
    fi
    ;;


  "ppa")
    # === $ bash_setup   ppa     ppa:abc.xyz/..."

    sudo add-apt-repository $1
    sudo apt-get update
    ;;

  "tidy")
    cd /progs
    if [[ ! -d tidy-html5 ]]; then
      git clone https://github.com/htacg/tidy-html5
    fi
    cd tidy-html5
    git pull
    cd build/cmake
    sudo apt-get install cmake xsltproc
    cmake ../.. -DCMAKE_INSTALL_PREFIX=/progs/tidy-html5 -DBUILD_SHARED_LIB:BOOL=OFF
    make
    make install
    ;;

  "make_link")
    # === make_link  source(old)  dest(new)
    make_link $@
    ;;

  "proc_tree")
    # === $ bash_setup proc_tree PID
    ps wwf -s $@
    ;;

  "show_err_line_trap")
    if [[ -z "$@" ]]; then
      nums=($($0 $action with_nums))
      start_at="$(expr ${nums[0]} + 1)"
      count="$(expr ${nums[1]} - ${nums[0]} - 1)"
      tail -n +"${start_at}" $0 | head -n $count
      exit 0
    fi

    echo $LINENO # ==============

    show_err_line () {
      local GREEN=$(tput setaf 2)
      local RED='\e[0;31m'
      local RESET_COLOR=$(tput sgr0)
      local exit_code="$1"
      local line="$2"

      echo -e -n "!!! ERROR: "                            1>&2
      echo -e -n "line: ${RED}${line}${RESET_COLOR} "      1>&2
      echo -e    "exit: ${RED}${exit_code}${RESET_COLOR}" 1>&2

      bash_setup descendent_procs "$$" -o pid= -o ppid= -o command= || :
    }

    trap 'show_err_line $? $LINENO' ERR

    echo $LINENO
    ;;

  "setup_traps")
    if [[ -z "$@" ]]; then
      nums=($($0 $action with_nums))
      start_at="$(expr ${nums[0]} + 1)"
      count="$(expr ${nums[1]} - ${nums[0]} - 1)"
      tail -n +"${start_at}" $0 | head -n $count
      exit 0
    fi

    echo $LINENO # ==============

    GREEN=$(tput setaf 2)
    RED='\e[0;31m'
    RESET_COLOR=$(tput sgr0)
    setup_traps () {

      verbose_wait () {
        echo ""
        echo -e "=== ${GREEN}Waiting${RESET_COLOR} in proc ${$}..."
        wait || :
        echo -e "=== ${GREEN}Done${RESET_COLOR} ($(basename $0) $$)"
      }

      on_err () {
        exit_code="$1"
        line="$2"

        echo -e -n "!!! ERROR: "                            1>&2
        echo -e -n "line: ${RED}${line}${RESET_COLOR} "      1>&2
        echo -e    "exit: ${RED}${exit_code}${RESET_COLOR}" 1>&2

        trap "exit ${exit_code}" INT

        if bash_setup is_process_group? $$
        then
          echo -e  "!!! Running: ${RED}setsid KILL -SIGINT -${$}${RESET_COLOR}" 1>&2
          setsid kill -SIGINT -$$
        else
          echo -e  "!!! Running: ${RED}setsid SIGINT_descendent_procs${RESET_COLOR} of ${$}" 1>&2
          setsid bash_setup SIGINT_descendent_procs $$
        fi
      }

      trap 'on_err $? $LINENO' ERR
      trap 'wait || :'         EXIT

    } # === setup_traps

    echo $LINENO
    ;;

  "pacnew")
    # === $ pacnew
    # === Finds any .pacnew, .pacsave, etc.
    # From: https://bbs.archlinux.org/viewtopic.php?id=193477
    find /etc/ \( -name \*.pacnew -o -name \*.pacorig -o -name \*.pacsave \) 2> /dev/null
    ;;

  "colorize")
    # === colorize RED some text
    # === colorize GREEN some text
    # === RED GREEN YELLOW BLUE PURPLE CYAN
    color_name=$1
    shift
    case "$color_name" in
      "RED" )
        color=1
        ;;
      "GREEN" )
        color=2
        ;;
      "YELLOW" )
        color=3
        ;;
      "BLUE" )
        color=4
        ;;
      "PURPLE" )
        color=5
        ;;
      "CYAN" )
        color=6
        ;;
      * )
        color=7
        ;;
    esac

    # From: stackoverflow.com/questions/635361/ksh-how-to-probe-stdin
    if [ -t 0 ]
    then
      echo -e "$(tput bold)$(tput setaf $color)$@$(tput sgr0)";
    else
      while read line; do
        echo -e "$(tput bold)$(tput setaf $color)${line}$(tput sgr0)";
      done
    fi
    ;;

  cp_unless_exists)
    orig=$1; shift
    target=$1; shift
    if [[ -e "$target" ]]; then
      echo "=== Skipping existing: $target"
      exit 0
    fi
    cp -i "$orig" "$target"
    ;;

  files-must-be-equal)
    # === __ must-be-same  NAME  "file1"  "file2"
    NAME="$1"; shift
    FILE1="$1"; shift
    FILE2="$1"; shift
    # if [[ -s "$FILE1" ]] && ! diff <(bash_setup trim-file "$FILE1") <(bash_setup trim-file "$FILE2"); then
    if [[ -s "$FILE1" ]] && ! diff <(bash_setup trim-file "$FILE1") <(bash_setup trim-file "$FILE2"); then
      echo -e "=== $NAME ${Red}Failed${Color_Off}:"
      echo -e "${Bold}      === Actual: =====${Color_Off} $FILE2"
      cat "$FILE2"
      echo -e "${Bold}      === Expected: ===${Color_Off} $FILE1"
      cat "$FILE1"
      echo -e "${Bold}      =================${Color_Off}"
      exit 1
    fi
    ;;

  dirs-are-equal)
    # === __   dirs-are-equal    dir1   dir2
    # === This is mainly used for specs/testing.
    dir1="$1"; shift
    dir2="$1"; shift
    if [[ ! -d "$dir1" ]]; then
      echo "!!! Not a dir: $dir1" 1>&2; exit 1
    fi
    if [[ ! -d "$dir2" ]]; then
      echo "!!! Not a dir: $dir2" 1>&2; exit 1
    fi

    # === Check if file names in dirs are the same:
    # Reminder: diff 0 exit == same
    diff <(tree "$dir1" | tail -n +2) <(tree "$dir2" | tail -n +2)

    # === Compare each file:
    while read FILE1 FILE2; do
      if ! diff "$FILE1" "$FILE2"; then
        echo "FILE1: $FILE1" 1>&2
        echo "FILE2: $FILE2" 1>&2
        exit 1
      fi
    done < <(paste <(find "$dir1" -type f | sort) <(find "$dir2" -type f | sort))
    ;;

  test-bash_setup)
    TEMP="/tmp/test-bash_setup"
    rm -rf "$TEMP"; mkdir -p "$TEMP"

    # === dirs-are-equal ======================
    DIR="$TEMP/dirs-are-equal"
    mkdir -p "$DIR"
    dir1="$DIR/temp1"; mkdir -p "$dir1"
    dir2="$DIR/temp2"; mkdir -p "$dir2"
    $0 dirs-are-equal "$dir1" "$dir2" || { stat=$?; echo -e "!!! ${Red}Failed${Color_Off} ($stat): empty dir == empty dir"; exit $stat; }

    touch "$dir1/file1"; touch "$dir2/file1"
    $0 dirs-are-equal "$dir1" "$dir2" || { stat=$?; echo -e "!!! ${Red}Failed${Color_Off} ($stat): empty file == empty file"; exit $stat; }

    touch "$dir1/file2"; touch "$dir2/file2-1"
    if $0 dirs-are-equal "$dir1" "$dir2" > $TEMP/output; then
      echo -e "!!! ${Red}Failed${Color_Off} different file name: file2 == file2-1"
      exit 1
    fi
    rm "$dir1/file2" "$dir2"/file2*

    echo "three" > "$dir1/file3";
    echo "three" > "$dir2/file3";
    if ! $0 dirs-are-equal "$dir1" "$dir2" > $TEMP/output; then
      echo -e "!!! ${Red}Failed${Color_Off} same names, same content: file3 == file3"
      cat $TEMP/output 1>&2
      exit 1
    fi

    echo "four"     > "$dir1/file4";
    echo "not four" > "$dir2/file4";
    if $0 dirs-are-equal "$dir1" "$dir2" &> $TEMP/output; then
      echo -e "!!! ${Red}Failed${Color_Off} same names, different content: file4 == file4"
      cat $TEMP/output 1>&2
      exit 1
    fi
    # === dirs-are-equal DONE =================

    echo -e "=== ${Green}Testing${Color_Off} is done"
    ;;

  test-and-watch)
    # === __  test-and-watch  # Used for testing bash_setup
    $0 test-bash_setup || :

    echo "=== Watching $THIS_DIR:"
    while read -r CHANGE; do
      dir=$(echo "$CHANGE" | cut -d' ' -f 1)
      op=$(echo "$CHANGE" | cut -d' ' -f 2)
      path="${dir}$(echo "$CHANGE" | cut -d' ' -f 3)"
      file="$(basename $path)"

      if [[ ! -f "$path" ]]; then
        continue
      fi

      if [[ "$(realpath -m "$path")" == "$(realpath -m "$0")" ]]; then
        echo ""
        echo "=== Reloading..."
        break
      fi

      echo "=== $CHANGE ($path)"
    done < <(inotifywait --quiet --monitor --event close_write --exclude .git/ -r "$THIS_DIR")
    $0 $ARGS
    ;;

  is_same_file)
    export TEMP_DIR="/tmp/is_same_file"
    mkdir -p "$TEMP_DIR"

    # === is_same_file  path/to/file
    # === Used to see if file has changed.
    # === This was created when Neovim was issue-ing a "CLOSE_WRITE,CLOSE"
    # === event on opening a file.
    file="$1"; shift

    temp_file="$TEMP_DIR/${file//\//_}"
    touch "$temp_file"
    if diff "$file" "$temp_file" >/dev/null; then
      exit 0
    fi
    cp "$file" "$temp_file"
    exit 1
    ;;

  *)
    echo "Unknown option: $action" 1>&2
    exit 1
    ;;

esac


