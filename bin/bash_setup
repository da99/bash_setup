#!/usr/bin/env bash
# -*- bash -*-
#
#
ignore="$IGNORE"
action="$1"
shift

set -u -e -o pipefail

BIN=/apps/bash_setup/bin
function git_is_clean {
    if ! git_repo_is_clean
    then
      echo -e "\n!!! GIT repo not clean enough.\n" 1>&2
      exit 1
    fi
}


case "$action" in

  "help")
    echo " ====================================================="
    echo ""
    echo " $ bash_setup bump               current"
    echo " $ bash_setup bump               major"
    echo " $ bash_setup bump               minor"
    echo " $ bash_setup bump               patch"
    echo " $ bash_setup bump_commit_push   major|minor|patch"
    echo " $ bash_setup push_tag"
    echo ""
    echo " $ bash_setup js_zero  substring"
    echo " $ bash_setup js_clean"
    echo ""
    echo " $ bash_setup files_zero  substring '*.ext'"
    echo ""
    echo " $ bash_setup release"
    echo ""
    echo " $ bash_setup o-x              dir  # === make bin files non-executable for others"
    echo ""
    echo " $ bash_setup watch  my_script -myargs -myargs"
    echo ""
    echo " $ bash_setup   ppa     ppa:abc.xyz/..."
    echo ""
    echo " ====================================================="
    echo ""
    exit 0
    ;;

  "bump")
    if [[ -z "$(which bump)" ]]; then
      echo "!!! install rubygem: gem install bump"
      exit 1
    fi
    if [[ "$1" != "current" ]]; then
      git_is_clean
      echo -e "=== Bumping from: $(bump current)\n"
    fi
    bash_setup js_clean
    bump $1 --no-commit --no-bundle
    ;;

  "bump_commit_push")
    bash_setup bump "$1"
    VER=$(cat VERSION)

    git_update
    git commit -m   "Bump: $VER"
    git tag         "v$VER"
    git push
    ;;

  "push_tag")
    if [[ -f VERSION ]]; then
      git push origin "v$(cat VERSION)"
    else
      if [[ -f "bower.json" ]]; then
        git push origin "v$(cat bower.json  | json version)"
      else
        echo "=== No version file found." 1>&2
        exit 1
      fi
    fi
    ;;

  "is_process_group??")
    if $0 is_process_group? $@ ; then
      echo "yes"
    else
      echo "no"
    fi
    ;;

  "SIGINT_descendent_procs")
    pid=$1
    for id in $($0 descendent_procs $pid)
    do
      kill -SIGINT $id || echo "=== Could not SIGINT $id" 1>&2
    done
    ;;

  "descendent_procs")
    pid="$1"
    pgid="$(ps -o pgid= $pid)"
    this_pid=$$
    this_pgid=$(ps -o pgid= $this_pid)
    this_parent=$(ps -o ppid= $this_pid)

    if [[ $pgid == $this_pgid ]] ; then
      echo "=== Run this using setsid" 1>&2
      exit 1
    fi

    # === Inspired from: http://superuser.com/a/784102
    declare -A CHILDS
    declare -A COMMS
    while read P PP PGID CMD;do
      if [[ "$PGID" -eq "$pgid" ]]; then
        CHILDS[$PP]+=" $P"
        COMMS[$P]="$CMD"
      fi
    done < <(ps -e -o pid= -o ppid= -o pgid= -o args=)

    walk() {
      if [[ $1 != $this_parent || $1 == $pid ]]; then
        [[ $1 != $pid ]] && echo $1

        if [[ ${CHILDS[$1]+is_set} ]]; then
          for i in ${CHILDS[$1]}; do
            walk $i
          done
        fi
      else
        echo "!!! IGNORING: $1" 1>&2
      fi
    }

    walk $pid
    ;;

  "proc_tree")
    pstree -a -A  -p -g $@
    ;;

  "proc_group")
    ps -o pgrp --no-headers --pid $1
    ;;

  "is_process_group?")
    [[ $1 == $($0 proc_group $1) ]]
    ;;

  "add_minus_sign_if_pgrp")
    target="$1"
    shift
    if $0 is_process_group? $target ; then
      echo "-$target"
    else
      echo $target
    fi
    ;;

  "watch")
    #
    #  For more info on inotifywait:
    #    http://manpages.ubuntu.com/manpages/hardy/man1/inotifywait.1.html
    #
    #  The script will send the output
    #  of inotifywaut to `my_script`.
    #
    #  Files/dirs with .git in the name are ignored.
    #  Example:
    #     .git
    #     ./.git
    #     ./dir/file.git/
    if [[ ! -z "$ignore" ]]
    then
      ignore="--exclude $ignore"
    fi

    cmd="$@"

    if [[ -z "$@" ]]
    then
      echo "No command given. Exiting..." 1>&2
      exit 1
    fi

    # temp="$(mktemp)"
    # bash_setup watch_run $temp "$cmd" &
    # run_id=$!

    # cleanup () {
      # kill $run_id || true
      # rm $temp
    # }

    # trap cleanup SIGINT SIGTERM

    # echo "---- Process: $run_id ----"

    # === From an answer by "technosaurus":
    #     http://stackoverflow.com/a/18295696/841803
    inotifywait -q -m --exclude .git/ $ignore -r . | while read CHANGE
    do

      op=$(echo "$CHANGE" | cut -d' ' -f 2)
      file=$(echo "$CHANGE" | cut -d' ' -f 3)

      if [[ ( ! "$op" =~ "NOWRITE" ) && ( "$op" =~ "CLOSE" || "$op" =~ "WRITE" )  && ! -z "$file" ]]
      then
        echo ""
        echo $CHANGE
        $cmd &
      fi

    done
    ;;



  "o-x")
    dir="$1"

    chmod o-x $dir/*/bin/*
    for x in $dir/*/bin; do
      echo "=== $x"
      ls -l $x
      echo ""
    done
    ;;

  "files_zero")
    SUBSTR="$1"
    ext="$2"
    FOUND="no"

    FILES="$(find . -type f -name "$ext" -not -wholename "*/.git*"  -and -not -wholename "*/specs/*" -and -not -wholename "*/bower_components/*" -and -not -wholename "*/vendor/*" -and -not -wholename "*/node_modules/*"  )"

    for FILE in $FILES ; do
      GREPS="$(grep -n "$SUBSTR" $FILE || echo '')"
      if [ ! -z "$GREPS" ]
      then
        echo -e -n "\e[01;31m$FILE\e[0m " 1>&2
        echo "contains $SUBSTR" 1>&2
        echo "$GREPS" 1>&2
        FOUND="yes"
      fi
    done

    if [ "$FOUND" = "yes" ]
    then
      exit 1
    fi
    ;;

  "js_zero")
    SUBSTR="$1"
    FOUND="no"

    FILES="$(find . -type f -name "*.js" -not -wholename "*/.git*" -and -not -wholename "*/bower_components/*" -and -not -wholename "*/vendor/*" -and -not -wholename "*/node_modules/*"  )"

    for FILE in $FILES ; do
      GREPS="$(grep -n "$SUBSTR" $FILE || echo '')"
      if [ ! -z "$GREPS" ]
      then
        echo -e -n "\e[01;31m$FILE\e[0m " 1>&2
        echo "contains $SUBSTR" 1>&2
        echo "$GREPS" 1>&2
        FOUND="yes"
      fi
    done

    if [ "$FOUND" = "yes" ]
    then
      exit 1
    fi
    ;;

  "js_clean")
    bash_setup js_zero console.log
    bash_setup js_zero debugger
    ;;

  "release")
    bash_setup push_tag
    git push
    ;;

  "ppa")
    sudo add-apt-repository $1
    sudo apt-get update
    ;;

  "tidy")
    cd /progs
    if [[ ! -d tidy-html5 ]]; then
      git clone https://github.com/htacg/tidy-html5
    fi
    cd tidy-html5
    git pull
    cd build/cmake
    sudo apt-get install cmake xsltproc
    cmake ../.. -DCMAKE_INSTALL_PREFIX=/progs/tidy-html5 -DBUILD_SHARED_LIB:BOOL=OFF
    make
    make install
    ;;

  "setup_traps")
    if [[ -z "$@" ]]; then
      nums=($($0 setup_traps with_nums))
      start_at="$(expr ${nums[0]} + 1)"
      count="$(expr ${nums[1]} - ${nums[0]} - 1)"
      tail -n +"${start_at}" $0 | head -n $count
      exit 0
    fi

    echo $LINENO # ==============

    GREEN=$(tput setaf 2)
    RED='\e[0;31m'
    RESET_COLOR=$(tput sgr0)
    setup_traps () {

      verbose_wait () {
        echo ""
        echo -e "=== ${GREEN}Waiting${RESET_COLOR} in proc ${$}..."
        wait || :
        echo -e "=== ${GREEN}Done${RESET_COLOR} ($(basename $0) $$)"
      }

      on_err () {
        exit_code="$1"
        line="$2"

        echo -e -n "!!! ERROR: "                            1>&2
        echo -e -n "line: ${RED}${line}${RESET_COLOR} "      1>&2
        echo -e    "exit: ${RED}${exit_code}${RESET_COLOR}" 1>&2

        trap "exit ${exit_code}" INT

        if bash_setup is_process_group? $$
        then
          echo -e  "!!! Running: ${RED}setsid KILL -SIGINT -${$}${RESET_COLOR}" 1>&2
          setsid kill -SIGINT -$$
        else
          echo -e  "!!! Running: ${RED}setsid SIGINT_descendent_procs${RESET_COLOR} of ${$}" 1>&2
          setsid bash_setup SIGINT_descendent_procs $$
        fi
      }

      trap 'on_err $? $LINENO' ERR
      trap 'wait || :'         EXIT

    } # === setup_traps

    echo $LINENO
    ;;

  *)
    echo "Unknown option: $action" 1>&2
    exit 1
    ;;

esac


