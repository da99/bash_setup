#!/usr/bin/env bash
# -*- bash -*-
#
#
ignore="$IGNORE"
action="$1"
IS_DEV="$IS_DEV"
shift

set -u -e -o pipefail

THIS_DIR="$(dirname $(dirname $0))"

BIN=/apps/bash_setup/bin
function git_is_clean {
    if ! git_repo_is_clean
    then
      echo -e "\n!!! GIT repo not clean enough.\n" 1>&2
      exit 1
    fi
}


case "$action" in

  "print_help")
    # === === Extract switch options from file
    # ===      that are followed by: # ===
    # === $ bash_setup print_help path/to/file

    file="$1"
    shift
    cmd_print=""
    cmd=""
    nl_printed=""
    IFS=$'\n'
    for line in $(cat $file)
    do
      if [[ $line =~ ^[\*\ +0-9A-Za-z\_\-\'\"]+\)$ ]]; then
        cmd=$(echo $line | tr -d '"'')')
        cmd_print=""
      else
        if [[ -n "$cmd" && $line =~ "# ===" ]]; then
          if [[ -z $cmd_print ]]; then
            echo $cmd
            cmd_print="true"
          fi
          echo ${line/'# ==='/''}
          nl_printed=""
        else
          cmd=""
          if [[ -z $nl_printed ]]; then
            echo ""
            nl_printed="true"
          fi
        fi
      fi

    done
    ;;

  "help"|"--help")
    $0 print_help $0
    ;;

  "rel_path_to_file")
    # === $ bash_setup rel_path_to_file  path  start
    # === See: https://docs.python.org/2/library/os.path.html#os.path.relpath
    python -c "import os.path; print os.path.relpath('$1', '$2')"
    ;;


  "sizes")
    # === $ sizes
    # === $ sizes  folder/path
    folder="./*"
    if [[ -n "$@" ]]; then
      folder="$1"
      shift
    fi
    # du -h $folder | grep --extended-regexp ".*[0-9]G.*" | sort --human-numeric-sort
    du -h --max-depth=0 $folder | sort --human-numeric-sort
    ;;

  "string_to_num")
    str=$1
    shift
    sum=0
    pos=0

    # === $ bash_setup  string_to_num   word  -> num
    while read -n1 char; do
      code="$(printf '%d\n' "'$char")"
      sum=$((sum + pos + code))
      pos=$((pos + 1))
    done < <(echo -n "$str")
    echo $sum
    ;;

  "dev!")
    # === $ bash_setup dev!
    # === Exits with code status 1 if "$IS_DEV" is null
    # === Exits with code status 0 if "$IS_DEV" is not null.
    if [[ -z "$IS_DEV" ]]; then
      echo "!!! Not a dev machine." 1>&2
      exit 1
    fi
    exit 0
    ;;

  "new_bin")
    # === $ bash_setup  new_bin
    # === $ bash_setup  new_bin  name
    if [[ -z "$@" ]]; then
      file_name="$(basename $(pwd))"
    else
      file_name=$1
      shift
    fi
    if [[ -f bin/${file_name} ]]; then
      echo "=== File already exists."
    else
      mkdir -p bin

      cp -i /apps/bash_setup/bin.template.sh bin/${file_name}
      echo "=== Wrote: bin/${file_name}"
    fi

    chmod +x bin/${file_name}
    ;;

  mush?)
    # === $ bash_setup mush? path/to/file.file
    # === If file exists, exists w/ 0, prints nothing to STDOUT.
    # === If file does NOT exists, prints to file,
    # ===  prints/repeats path/to/file.file to STDOUT
    file="$1"
    shift
    if [[ -f $file ]]; then
      exit 0
    else
      bash_setup mush > $file
      echo $file
    fi
    ;;

  mush)
    # === Wrapper for mush (Mustache for Bash)
    # === https://github.com/jwerle/mush
    # === Use it just like the mush executable
    mush="${THIS_DIR}/bin/mush"
    if [[ ! -f "$mush" ]]; then
      wget -O $mush "https://raw.githubusercontent.com/jwerle/mush/master/mush.sh"
      chmod +x $mush
    fi
    $mush "$@"
    ;;

  "Capitalize")
    # === $ Capitalize wOrD => Word
    # Based on: http://stackoverflow.com/a/12487465/841803
    word="$1"
    first="$(tr '[:lower:]' '[:upper:]' <<< ${word:0:1})"
    rest="$(tr  '[:upper:]' '[:lower:]' <<< ${word:1})"
    echo "$first$rest"
    ;;

  "Model_Name")
    # === $ Model_Name app_name => App_Name
    # Based on: http://stackoverflow.com/questions/779847/sed-change-case-of-substitution-group
    echo "$@" | sed -e 's/_\([a-z]\)/_\U\1/g' -e 's/^\([a-z]\)/\U\1/g'
    ;;

  "UPPER")
    # === $ lower wOrD => WORD
    word="$1"
    echo "$(tr  '[:lower:]' '[:upper:]' <<< ${word})"
    ;;

  "lower")
    # === $ lower wOrD => word
    word="$1"
    echo "$(tr  '[:upper:]' '[:lower:]' <<< ${word})"
    ;;

  "app_name")
    if [[ -z "$@" ]]; then
      echo "$(basename $(pwd))"
    else
      echo "$1"
    fi
    ;;

  "is_process_group??")
    if $0 is_process_group? $@ ; then
      echo "yes"
    else
      echo "no"
    fi
    ;;

  "SIGINT_descendent_procs")
    pid=$1

    for id in $($0 descendent_procs $pid)
    do
      kill -SIGINT $id || echo "=== Could not SIGINT $id" 1>&2
    done
    ;;

  "descendent_procs")
    # === bash_setup descendent_procs MY_PID
    # === bash_setup descendent_procs MY_PID [args to: ps -p PID ...]
    # === You can then get info on each PID using xargs:
    # === Any other way, and you will get sub-processes/sub-shells.
    # === Example:  bash_setup descende... | xargs ...     # ==> Prints out PIDs of xargs
    # === Example:  while ... done < <(bash_setup desc...) # ==> Prints out PIDs of '<(bash_setup ...)'
    target="$1"
    shift
    this_pid="$$"

    raw="$(pstree -p $target)"
    while read PID
    do
      if [[ "$PID" != "$target" && "$PID" != "$this_pid" ]] && ps --pid $PID &>/dev/null; then
        if [[ -z "$@" ]]; then
          echo $PID
        else
          ps -p $PID "$@"
        fi
      fi
    done < <(echo "$raw" | grep -o '([0-9]\+)' | grep -o '[0-9]\+' )
    ;;

  "proc_tree")
    pstree -a -A  -p -g $@
    ;;

  "proc_group")
    ps -o pgrp --no-headers --pid $1
    ;;

  "is_process_group?")
    [[ $1 == $($0 proc_group $1) ]]
    ;;

  "add_minus_sign_if_pgrp")
    target="$1"
    shift
    if $0 is_process_group? $target ; then
      echo "-$target"
    else
      echo $target
    fi
    ;;

  "watch")
    # === $ bash_setup watch  my_script -myargs -myargs"

    #
    #  For more info on inotifywait:
    #    http://manpages.ubuntu.com/manpages/hardy/man1/inotifywait.1.html
    #
    #  The script will send the output
    #  of inotifywaut to `my_script`.
    #
    #  Files/dirs with .git in the name are ignored.
    #  Example:
    #     .git
    #     ./.git
    #     ./dir/file.git/

    files="$1"
    shift
    cmd="$@"

    if [[ -z "$@" ]]
    then
      echo "No command given. Exiting..." 1>&2
      exit 1
    fi

    # === From an answer by "technosaurus":
    #     http://stackoverflow.com/a/18295696/841803
    echo "=== Watching: $files -> $cmd"
    while read -r CHANGE
    do
      dir=$(echo "$CHANGE" | cut -d' ' -f 1)
      op=$(echo "$CHANGE" | cut -d' ' -f 2)
      path="${dir}$(echo "$CHANGE" | cut -d' ' -f 3)"
      file="$(basename $path)"

      echo ""
      echo === $CHANGE === "$cmd"
      eval $cmd || :
    done < <(inotifywait --quiet --monitor --event close_write --exclude .git/ $files)
    ;;



  "o-x")
    # === === make bin files non-executable for others
    # === $ bash_setup o-x dir

    dir="$1"

    chmod o-x $dir/*/bin/*
    for x in $dir/*/bin; do
      echo "=== $x"
      ls -l $x
      echo ""
    done
    ;;

  "files_zero")
    # === $ bash_setup files_zero  substring '*.ext'"

    SUBSTR="$1"
    ext="$2"
    FOUND="no"

    FILES="$(find . -type f -name "$ext" -not -wholename "*/.git*"  -and -not -wholename "*/specs/*" -and -not -wholename "*/bower_components/*" -and -not -wholename "*/vendor/*" -and -not -wholename "*/node_modules/*"  )"

    for FILE in $FILES ; do
      GREPS="$(grep -n "$SUBSTR" $FILE || echo '')"
      if [ ! -z "$GREPS" ]
      then
        echo -e -n "\e[01;31m$FILE\e[0m " 1>&2
        echo "contains $SUBSTR" 1>&2
        echo "$GREPS" 1>&2
        FOUND="yes"
      fi
    done

    if [ "$FOUND" = "yes" ]
    then
      exit 1
    fi
    ;;


  "ppa")
    # === $ bash_setup   ppa     ppa:abc.xyz/..."

    sudo add-apt-repository $1
    sudo apt-get update
    ;;

  "tidy")
    cd /progs
    if [[ ! -d tidy-html5 ]]; then
      git clone https://github.com/htacg/tidy-html5
    fi
    cd tidy-html5
    git pull
    cd build/cmake
    sudo apt-get install cmake xsltproc
    cmake ../.. -DCMAKE_INSTALL_PREFIX=/progs/tidy-html5 -DBUILD_SHARED_LIB:BOOL=OFF
    make
    make install
    ;;

  "proc_tree")
    # === $ bash_setup proc_tree PID
    ps wwf -s $@
    ;;

  "show_err_line_trap")
    if [[ -z "$@" ]]; then
      nums=($($0 $action with_nums))
      start_at="$(expr ${nums[0]} + 1)"
      count="$(expr ${nums[1]} - ${nums[0]} - 1)"
      tail -n +"${start_at}" $0 | head -n $count
      exit 0
    fi

    echo $LINENO # ==============

    show_err_line () {
      local GREEN=$(tput setaf 2)
      local RED='\e[0;31m'
      local RESET_COLOR=$(tput sgr0)
      local exit_code="$1"
      local line="$2"

      echo -e -n "!!! ERROR: "                            1>&2
      echo -e -n "line: ${RED}${line}${RESET_COLOR} "      1>&2
      echo -e    "exit: ${RED}${exit_code}${RESET_COLOR}" 1>&2

      bash_setup descendent_procs "$$" -o pid= -o ppid= -o command= || :
    }

    trap 'show_err_line $? $LINENO' ERR

    echo $LINENO
    ;;

  "setup_traps")
    if [[ -z "$@" ]]; then
      nums=($($0 $action with_nums))
      start_at="$(expr ${nums[0]} + 1)"
      count="$(expr ${nums[1]} - ${nums[0]} - 1)"
      tail -n +"${start_at}" $0 | head -n $count
      exit 0
    fi

    echo $LINENO # ==============

    GREEN=$(tput setaf 2)
    RED='\e[0;31m'
    RESET_COLOR=$(tput sgr0)
    setup_traps () {

      verbose_wait () {
        echo ""
        echo -e "=== ${GREEN}Waiting${RESET_COLOR} in proc ${$}..."
        wait || :
        echo -e "=== ${GREEN}Done${RESET_COLOR} ($(basename $0) $$)"
      }

      on_err () {
        exit_code="$1"
        line="$2"

        echo -e -n "!!! ERROR: "                            1>&2
        echo -e -n "line: ${RED}${line}${RESET_COLOR} "      1>&2
        echo -e    "exit: ${RED}${exit_code}${RESET_COLOR}" 1>&2

        trap "exit ${exit_code}" INT

        if bash_setup is_process_group? $$
        then
          echo -e  "!!! Running: ${RED}setsid KILL -SIGINT -${$}${RESET_COLOR}" 1>&2
          setsid kill -SIGINT -$$
        else
          echo -e  "!!! Running: ${RED}setsid SIGINT_descendent_procs${RESET_COLOR} of ${$}" 1>&2
          setsid bash_setup SIGINT_descendent_procs $$
        fi
      }

      trap 'on_err $? $LINENO' ERR
      trap 'wait || :'         EXIT

    } # === setup_traps

    echo $LINENO
    ;;

  *)
    echo "Unknown option: $action" 1>&2
    exit 1
    ;;

esac


