#!/usr/bin/env bash
# -*- bash -*-
#
#
ignore="$IGNORE"
action="$1"
shift

set -u -e -o pipefail

BIN=/apps/bash_setup/bin
function git_is_clean {
    if ! git_repo_is_clean
    then
      echo -e "\n!!! GIT repo not clean enough.\n" 1>&2
      exit 1
    fi
}


case "$action" in

  "print_help")
    # === === Extract switch options from file
    # ===      that are followed by: # ===
    # === $ bash_setup print_help path/to/file

    file="$1"
    shift
    cmd_print=""
    cmd=""
    nl_printed=""
    IFS=$'\n'
    for line in $(cat $file)
    do
      if [[ $line =~ ^[\ +0-9A-Za-z\_\-\'\"]+\)$ ]]; then
        cmd=$(echo $line | tr -d '"'')')
        cmd_print=""
      else
        if [[ -n "$cmd" && $line =~ "# ===" ]]; then
          if [[ -z $cmd_print ]]; then
            echo $cmd
            cmd_print="true"
          fi
          echo ${line/'# ==='/''}
          nl_printed=""
        else
          cmd=""
          if [[ -z $nl_printed ]]; then
            echo ""
            nl_printed="true"
          fi
        fi
      fi

    done
    ;;

  "help")
    $0 print_help $0
    ;;

  "string_to_num")
    str=$1
    shift
    sum=0
    pos=0

    # === $ bash_setup  string_to_num   word  -> num
    while read -n1 char; do
      code="$(printf '%d\n' "'$char")"
      sum=$((sum + pos + code))
      pos=$((pos + 1))
    done < <(echo -n "$str")
    echo $sum
    ;;

  "new_bin")
    # === $ bash_setup  new_bin
    # === $ bash_setup  new_bin  name
    if [[ -z "$@" ]]; then
      file_name="$(basename $(pwd))"
    else
      file_name=$1
      shift
    fi
    if [[ -f bin/${file_name} ]]; then
      echo "=== File already exists."
    else
      mkdir -p bin

      cp -i /apps/bash_setup/bin.template.sh bin/${file_name}
      echo "=== Wrote: bin/${file_name}"
    fi

    chmod +x bin/${file_name}
    ;;

  "is_process_group??")
    if $0 is_process_group? $@ ; then
      echo "yes"
    else
      echo "no"
    fi
    ;;

  "SIGINT_descendent_procs")
    pid=$1

    for id in $($0 descendent_procs $pid)
    do
      kill -SIGINT $id || echo "=== Could not SIGINT $id" 1>&2
    done
    ;;

  "descendent_procs")
    pid="$1"
    pgid="$(ps -o pgid= $pid)"
    this_pid=$$
    this_pgid=$(ps -o pgid= $this_pid)
    this_parent=$(ps -o ppid= $this_pid)

    if [[ $pgid == $this_pgid ]] ; then
      echo "=== Run this using setsid" 1>&2
      exit 1
    fi

    # === Inspired from: http://superuser.com/a/784102
    declare -A CHILDS
    while read P PP PGID CMD;do
      if [[ "$PGID" -eq "$pgid" ]]; then
        CHILDS[$PP]+=" $P"
      fi
    done < <(ps -e -o pid= -o ppid= -o pgid= -o args=)

    walk() {
      [[ $1 != $pid ]] && echo $1 || :

      if [[ ${CHILDS[$1]+is_set} ]]; then
        for i in ${CHILDS[$1]}; do
          walk $i
        done
      fi
    }

    walk $pid
    ;;

  "proc_tree")
    pstree -a -A  -p -g $@
    ;;

  "proc_group")
    ps -o pgrp --no-headers --pid $1
    ;;

  "is_process_group?")
    [[ $1 == $($0 proc_group $1) ]]
    ;;

  "add_minus_sign_if_pgrp")
    target="$1"
    shift
    if $0 is_process_group? $target ; then
      echo "-$target"
    else
      echo $target
    fi
    ;;

  "watch")
    # === $ bash_setup watch  my_script -myargs -myargs"

    #
    #  For more info on inotifywait:
    #    http://manpages.ubuntu.com/manpages/hardy/man1/inotifywait.1.html
    #
    #  The script will send the output
    #  of inotifywaut to `my_script`.
    #
    #  Files/dirs with .git in the name are ignored.
    #  Example:
    #     .git
    #     ./.git
    #     ./dir/file.git/
    if [[ ! -z "$ignore" ]]
    then
      ignore="--exclude $ignore"
    fi

    cmd="$@"

    if [[ -z "$@" ]]
    then
      echo "No command given. Exiting..." 1>&2
      exit 1
    fi

    # temp="$(mktemp)"
    # bash_setup watch_run $temp "$cmd" &
    # run_id=$!

    # cleanup () {
      # kill $run_id || true
      # rm $temp
    # }

    # trap cleanup SIGINT SIGTERM

    # echo "---- Process: $run_id ----"

    # === From an answer by "technosaurus":
    #     http://stackoverflow.com/a/18295696/841803
    inotifywait -q -m --exclude .git/ $ignore -r . | while read CHANGE
    do

      op=$(echo "$CHANGE" | cut -d' ' -f 2)
      file=$(echo "$CHANGE" | cut -d' ' -f 3)

      if [[ ( ! "$op" =~ "NOWRITE" ) && ( "$op" =~ "CLOSE" || "$op" =~ "WRITE" )  && ! -z "$file" ]]
      then
        echo ""
        echo $CHANGE
        $cmd &
      fi

    done
    ;;



  "o-x")
    # === === make bin files non-executable for others
    # === $ bash_setup o-x dir

    dir="$1"

    chmod o-x $dir/*/bin/*
    for x in $dir/*/bin; do
      echo "=== $x"
      ls -l $x
      echo ""
    done
    ;;

  "files_zero")
    # === $ bash_setup files_zero  substring '*.ext'"

    SUBSTR="$1"
    ext="$2"
    FOUND="no"

    FILES="$(find . -type f -name "$ext" -not -wholename "*/.git*"  -and -not -wholename "*/specs/*" -and -not -wholename "*/bower_components/*" -and -not -wholename "*/vendor/*" -and -not -wholename "*/node_modules/*"  )"

    for FILE in $FILES ; do
      GREPS="$(grep -n "$SUBSTR" $FILE || echo '')"
      if [ ! -z "$GREPS" ]
      then
        echo -e -n "\e[01;31m$FILE\e[0m " 1>&2
        echo "contains $SUBSTR" 1>&2
        echo "$GREPS" 1>&2
        FOUND="yes"
      fi
    done

    if [ "$FOUND" = "yes" ]
    then
      exit 1
    fi
    ;;


  "ppa")
    # === $ bash_setup   ppa     ppa:abc.xyz/..."

    sudo add-apt-repository $1
    sudo apt-get update
    ;;

  "tidy")
    cd /progs
    if [[ ! -d tidy-html5 ]]; then
      git clone https://github.com/htacg/tidy-html5
    fi
    cd tidy-html5
    git pull
    cd build/cmake
    sudo apt-get install cmake xsltproc
    cmake ../.. -DCMAKE_INSTALL_PREFIX=/progs/tidy-html5 -DBUILD_SHARED_LIB:BOOL=OFF
    make
    make install
    ;;

  "setup_traps")
    if [[ -z "$@" ]]; then
      nums=($($0 setup_traps with_nums))
      start_at="$(expr ${nums[0]} + 1)"
      count="$(expr ${nums[1]} - ${nums[0]} - 1)"
      tail -n +"${start_at}" $0 | head -n $count
      exit 0
    fi

    echo $LINENO # ==============

    GREEN=$(tput setaf 2)
    RED='\e[0;31m'
    RESET_COLOR=$(tput sgr0)
    setup_traps () {

      verbose_wait () {
        echo ""
        echo -e "=== ${GREEN}Waiting${RESET_COLOR} in proc ${$}..."
        wait || :
        echo -e "=== ${GREEN}Done${RESET_COLOR} ($(basename $0) $$)"
      }

      on_err () {
        exit_code="$1"
        line="$2"

        echo -e -n "!!! ERROR: "                            1>&2
        echo -e -n "line: ${RED}${line}${RESET_COLOR} "      1>&2
        echo -e    "exit: ${RED}${exit_code}${RESET_COLOR}" 1>&2

        trap "exit ${exit_code}" INT

        if bash_setup is_process_group? $$
        then
          echo -e  "!!! Running: ${RED}setsid KILL -SIGINT -${$}${RESET_COLOR}" 1>&2
          setsid kill -SIGINT -$$
        else
          echo -e  "!!! Running: ${RED}setsid SIGINT_descendent_procs${RESET_COLOR} of ${$}" 1>&2
          setsid bash_setup SIGINT_descendent_procs $$
        fi
      }

      trap 'on_err $? $LINENO' ERR
      trap 'wait || :'         EXIT

    } # === setup_traps

    echo $LINENO
    ;;

  *)
    echo "Unknown option: $action" 1>&2
    exit 1
    ;;

esac


