#!/usr/bin/env bash
# -*- bash -*-
#
#

ARGS="$@"
ignore="$IGNORE"
action="$1"
IS_DEV="$IS_DEV"
shift

set -u -e -o pipefail

THIS_DIR="$(dirname "$(dirname "$(readlink "$0")")")"
PATH="$PATH:$THIS_DIR/../sh_color/bin"
BIN=/apps/bash_setup/bin


function git_is_clean {
    if ! my_git is-clean
    then
      echo -e "\n!!! GIT repo not clean enough.\n" 1>&2
      exit 1
    fi
}

function make_link {
  local orig=$1
  local target=$2

  # IF broken link exists, remove
  if [[ -h "$target" && ! -e "$(readlink $target)" ]]; then
    echo -e "\n!!! trashing broken link: $target\n"
    trash-put $target
  fi

  # --- IF it does NOT exit?
  if [[ ! -e "$target" ]]
  then # --- create link
    ln -s $orig $target
    sh_color GREEN "--- Linked: $orig {{$target}}"
  else

    # --- IF is a sym link?
    if [[ -h "$target" && "$(readlink -f "$target")" == "$(readlink -f $orig)" ]]
    then
      echo "Already sym link: $target"

    else
      sh_color RED -e "\n=== Check existing object: {{$target}}"
      echo -e "\n diff $orig $target\n\n" 1>&2
      exit 1

    fi # --- valid sym link?
  fi # --- ! -e

}


case "$action" in

  "help"|"--help")
    $0 print-help $0
    ;;

  trim-file)
    # === __ trim-file  path/to/file
    # === cat path/to/file | __ trim-file
    grep  -Pzo '(?s)\A[\s\n]*\K(.+?)(?=[\s\n]*\Z)' $@
    ;;

  backup)
    file="$1"
    backup="$1.backup"
    if [[ -f "$backup" ]]; then
      echo "Backup file already exists: $backup" 1>&2
      exit 1
    fi
    set '-x'
    cp -i "$file" "$backup"
    ;;

  "restore")
    file="$1"
    backup="$1.backup"
    if [[ ! -f "$backup" ]]; then
      echo "Backup file does *not* exist: $backup" 1>&2
      exit 1
    fi
    set '-x'
    { [[ -f "$file" ]] && trash-put $file; } || :
    mv -i "$backup" "$file"
    ;;

  "rel_path_to_file")
    # === $ bash_setup rel_path_to_file  path  start
    # === See: https://docs.python.org/2/library/os.path.html#os.path.relpath
    python -c "import os.path; print os.path.relpath('$1', '$2')"
    ;;

  "upgrade")
    # === upgrade
    case "$@" in
      "fzf")
        cd /progs/fzf
        git pull
        ./install
        ;;

      "fzy")
        $0 install fzy
        ;;

      esac
    ;;

  "install")
    case "$@" in

      "fzf")
        cd /progs
        if [[ ! -d fzf ]]; then
          git clone --depth 1 https://github.com/junegunn/fzf.git
          $0 make_link /progs/fzf $HOME/.fzf
        fi

        ~/.fzf/install

        cd /progs
        if [[ -d fzy ]]; then
          cd fzy
          git pull
        else
          git clone https://github.com/jhawthorn/fzy
          cd fzy
        fi

        ;;

      "fzy")
        set '-x'
        cd /progs
        if [[ -d fzy ]]; then
          cd fzy
          OLD_TAG="$(git rev-parse HEAD)"
          git pull
          NEW_TAG="$(git rev-parse HEAD)"
        else
          OLD_TAG=""
          git clone https://github.com/jhawthorn/fzy
          NEW_TAG="[new]"
        fi

        if [[ "$OLD_TAG" != "$NEW_TAG" ]]; then
          cd fzy
          PREFIX="$PWD/bin" make
          PREFIX="$PWD/bin" make install
          echo "=== done instaling fzy"
        else
          echo "=== fzy already the latest."

        fi
        ;;

      *)
        # === install  # installs various packages/libs
        # === NOTE: libuv is a lib for async I/O
        $0 make_link $THIS_DIR/dots/.bashrc       $HOME/.bashrc
        $0 make_link $THIS_DIR/dots/.bash_profile $HOME/.bash_profile
        sudo pacmatic -S --needed \
          bash-completion   \
          inotify-tools     \
          libuv
        ;;
    esac
    ;; # === install

  "dev!")
    # === $ bash_setup dev!
    # === Exits with code status 1 if "$IS_DEV" is null
    # === Exits with code status 0 if "$IS_DEV" is not null.
    if [[ -z "$IS_DEV" ]]; then
      echo "!!! Not a dev machine." 1>&2
      exit 1
    fi
    exit 0
    ;;


  "o-x")
    # === === make bin files non-executable for others
    # === $ bash_setup o-x dir

    dir="$1"

    chmod o-x $dir/*/bin/*
    for x in $dir/*/bin; do
      echo "=== $x"
      ls -l $x
      echo ""
    done
    ;;

  "files_zero")
    # === $ bash_setup files_zero  substring '*.ext'"

    SUBSTR="$1"
    ext="$2"
    FOUND="no"

    FILES="$(find . -type f -name "$ext" -not -wholename "*/.git*"  -and -not -wholename "*/specs/*" -and -not -wholename "*/bower_components/*" -and -not -wholename "*/vendor/*" -and -not -wholename "*/node_modules/*"  )"

    for FILE in $FILES ; do
      GREPS="$(grep -n "$SUBSTR" $FILE || echo '')"
      if [ ! -z "$GREPS" ]
      then
        sh_color BOLD -n "{{$FILE}} " 1>&2
        echo "contains $SUBSTR" 1>&2
        echo "$GREPS" 1>&2
        FOUND="yes"
      fi
    done

    if [ "$FOUND" = "yes" ]
    then
      exit 1
    fi
    ;;


  "ppa")
    # === $ bash_setup   ppa     ppa:abc.xyz/..."

    sudo add-apt-repository $1
    sudo apt-get update
    ;;

  "tidy")
    cd /progs
    if [[ ! -d tidy-html5 ]]; then
      git clone https://github.com/htacg/tidy-html5
    fi
    cd tidy-html5
    git pull
    cd build/cmake
    sudo apt-get install cmake xsltproc
    cmake ../.. -DCMAKE_INSTALL_PREFIX=/progs/tidy-html5 -DBUILD_SHARED_LIB:BOOL=OFF
    make
    make install
    ;;

  "make_link")
    # === make_link  source(old)  dest(new)
    make_link $@
    ;;

  "show_err_line_trap")
    if [[ -z "$@" ]]; then
      nums=($($0 $action with_nums))
      start_at="$(expr ${nums[0]} + 1)"
      count="$(expr ${nums[1]} - ${nums[0]} - 1)"
      tail -n +"${start_at}" $0 | head -n $count
      exit 0
    fi

    echo $LINENO # ==============

    show_err_line () {
      local exit_code="$1"
      local line="$2"

      echo -e -n "!!! ERROR: "                            1>&2
      sh_color RED -n "line: {{${line}}} "      1>&2
      sh_color RED    "exit: {{${exit_code}}}" 1>&2

      bash_setup descendent_procs "$$" -o pid= -o ppid= -o command= || :
    }

    trap 'show_err_line $? $LINENO' ERR

    echo $LINENO
    ;;

  "setup_traps")
    if [[ -z "$@" ]]; then
      nums=($($0 $action with_nums))
      start_at="$(expr ${nums[0]} + 1)"
      count="$(expr ${nums[1]} - ${nums[0]} - 1)"
      tail -n +"${start_at}" $0 | head -n $count
      exit 0
    fi

    echo $LINENO # ==============

    setup_traps () {

      verbose_wait () {
        echo ""
        sh_color ORANGE "=== {{Waiting}} in proc ${$}..."
        wait || :
        sh_color GREEN "=== {{Done}} ($(basename $0) $$)"
      }

      on_err () {
        exit_code="$1"
        line="$2"

        echo -e -n "!!! ERROR: "                            1>&2
        sh_color RED -n "line: {{${line}}} "      1>&2
        sh_color RED    "exit: {{${exit_code}}}" 1>&2

        trap "exit ${exit_code}" INT

        if bash_setup is_process_group? $$
        then
          sh_color BOLD "!!! Running: {{setsid KILL -SIGINT -${$}}}" 1>&2
          setsid kill -SIGINT -$$
        else
          sh_color RED  "!!! Running: {{setsid SIGINT_descendent_procs}} of ${$}" 1>&2
          setsid bash_setup SIGINT_descendent_procs $$
        fi
      }

      trap 'on_err $? $LINENO' ERR
      trap 'wait || :'         EXIT

    } # === setup_traps

    echo $LINENO
    ;;

  "pacnew")
    # === $ pacnew
    # === Finds any .pacnew, .pacsave, etc.
    # From: https://bbs.archlinux.org/viewtopic.php?id=193477
    find /etc/ \( -name \*.pacnew -o -name \*.pacorig -o -name \*.pacsave \) 2> /dev/null
    ;;


  cp_unless_exists)
    orig=$1; shift
    target=$1; shift
    if [[ -e "$target" ]]; then
      echo "=== Skipping existing: $target"
      exit 0
    fi
    cp -i "$orig" "$target"
    ;;

  files-must-be-equal)
    # === __ must-be-same  NAME  "file1"  "file2"
    NAME="$1"; shift
    FILE1="$1"; shift
    FILE2="$1"; shift
    # if [[ -s "$FILE1" ]] && ! diff <(bash_setup trim-file "$FILE1") <(bash_setup trim-file "$FILE2"); then
    if [[ -s "$FILE1" ]] && ! diff <(bash_setup trim-file "$FILE1") <(bash_setup trim-file "$FILE2"); then
      sh_color RED "=== $NAME {{Failed}}:"
      sh_color BOLD "{{      === Actual: =====}} $FILE2"
      cat "$FILE2"
      sh_color BOLD "{{      === Expected: ===}} $FILE1"
      cat "$FILE1"
      sh_color BOLD "{{      =================}}"
      exit 1
    fi
    ;;

  remove-empty-lines)
    # ===  __  remove-empty-lines   "$FILE"
    grep -v --extended-regexp '^\s*$' $@
    ;;

  diff)
    # === __   diff    "file1"        "file2"
    # === __   diff    "file.json"    "file.json"
    FILE1="$1"; shift
    FILE2="$1"; shift
    if [[ "$FILE1" == *.json && "$FILE2" == *.json ]]; then
      diff \
        <(node -pe "JSON.parse(process.argv[1])" "$(cat "$FILE1")") \
        <(node -pe "JSON.parse(process.argv[1])" "$(cat "$FILE2")")
    else
      diff <($0 remove-empty-lines "$FILE1")  <($0 remove-empty-lines "$FILE2")
    fi
    ;;


  test-bash_setup)
    TEMP="/tmp/test-bash_setup"
    rm -rf "$TEMP"; mkdir -p "$TEMP"

    # === dirs-are-equal ======================
    DIR="$TEMP/dirs-are-equal"
    mkdir -p "$DIR"
    dir1="$DIR/temp1"; mkdir -p "$dir1"
    dir2="$DIR/temp2"; mkdir -p "$dir2"
    $0 dirs-are-equal "$dir1" "$dir2" || { stat=$?; sh_color RED "!!! {{Failed}} ($stat): empty dir == empty dir"; exit $stat; }

    touch "$dir1/file1"; touch "$dir2/file1"
    $0 dirs-are-equal "$dir1" "$dir2" || { stat=$?; sh_color RED "!!! {{Failed}} ($stat): empty file == empty file"; exit $stat; }

    touch "$dir1/file2"; touch "$dir2/file2-1"
    if $0 dirs-are-equal "$dir1" "$dir2" > $TEMP/output; then
      sh_color RED "!!! {{Failed}} different file name: file2 == file2-1"
      exit 1
    fi
    rm "$dir1/file2" "$dir2"/file2*

    echo "three" > "$dir1/file3";
    echo "three" > "$dir2/file3";
    if ! $0 dirs-are-equal "$dir1" "$dir2" > $TEMP/output; then
      sh_color RED "!!! {{Failed}} same names, same content: file3 == file3"
      cat $TEMP/output 1>&2
      exit 1
    fi

    echo "four"     > "$dir1/file4";
    echo "not four" > "$dir2/file4";
    if $0 dirs-are-equal "$dir1" "$dir2" &> $TEMP/output; then
      sh_color RED "!!! {{Failed}} same names, different content: file4 == file4"
      cat $TEMP/output 1>&2
      exit 1
    fi
    # === dirs-are-equal DONE =================

    sh_color GREEN "=== {{Testing}} is done"
    ;;

  test-and-watch)
    # === __  test-and-watch  # Used for testing bash_setup
    $0 test-bash_setup || :

    echo "=== Watching $THIS_DIR:"
    while read -r CHANGE; do
      dir=$(echo "$CHANGE" | cut -d' ' -f 1)
      op=$(echo "$CHANGE" | cut -d' ' -f 2)
      path="${dir}$(echo "$CHANGE" | cut -d' ' -f 3)"
      file="$(basename $path)"

      if [[ ! -f "$path" ]]; then
        continue
      fi

      if [[ "$(realpath -m "$path")" == "$(realpath -m "$0")" ]]; then
        echo ""
        echo "=== Reloading..."
        break
      fi

      echo "=== $CHANGE ($path)"
    done < <(inotifywait --quiet --monitor --event close_write --exclude .git/ -r "$THIS_DIR")
    $0 $ARGS
    ;;

  *)
    mksh_setup "$action" "$@"
    ;;

esac


